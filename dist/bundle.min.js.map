{"version":3,"file":"bundle.min.js","mappings":"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","sources":["webpack://musicode/./src/utils/notes.ts","webpack://musicode/./src/audio/createVisualiser.ts","webpack://musicode/./src/utils/getPeaks.ts","webpack://musicode/./src/utils/constants.ts","webpack://musicode/./src/utils/getFillColor.ts","webpack://musicode/./src/utils/updateMax.ts","webpack://musicode/./src/utils/closest.ts","webpack://musicode/./src/audio/getMicrophone.ts","webpack://musicode/./src/index.ts","webpack://musicode/./src/audio/createAnalyser.ts"],"sourcesContent":["var NOTES_GAP = 1 / 12;\nvar notesNames = [\"A\", \"A#\", \"B\", \"C\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\"];\nvar notes = [];\nvar currentFirst = 55;\nvar _loop_1 = function (i) {\n    notesNames.forEach(function (note, idx) {\n        if (idx == 0 && i > 0)\n            currentFirst = currentFirst * 2;\n        var frequency_jump = idx * NOTES_GAP * currentFirst;\n        notes.push({ f: currentFirst + frequency_jump, n: note });\n    });\n};\nfor (var i = 0; i < 4; i++) {\n    _loop_1(i);\n}\nexport var NOTES = notes;\n","import { BASELINE, MAX_VALUE } from \"../utils/constants\";\nimport { getFillColor } from \"../utils/getFillColor\";\nimport { getPeaks } from \"../utils/getPeaks\";\n/**\n * Draws the sound data of the provided analyser if the provided canvas\n * so that humans can see the frequencies and volume as bars.\n *\n * @param {*} analyser The analyser giving us the data to draw on the canvas.\n * @param {*} canvas The canvas context where the bars will be drawn\n */\nexport function createVisualiser(analyser, canvas) {\n    var canvasCtx = canvas.getContext(\"2d\");\n    var bufferSize = analyser.frequencyBinCount;\n    var bufferData = new Uint8Array(bufferSize);\n    canvasCtx.clearRect(0, 0, canvas.width, canvas.height);\n    var drawAlt = function () {\n        var drawVisual = requestAnimationFrame(drawAlt);\n        analyser.getByteFrequencyData(bufferData);\n        canvasCtx.fillStyle = 'rgb(0, 0, 0)';\n        canvasCtx.fillRect(0, 0, canvas.width, canvas.height);\n        var xRatio = (canvas.width / bufferSize) * 2.5;\n        var yRatio = canvas.height / MAX_VALUE;\n        var p = getPeaks(bufferData, BASELINE);\n        bufferData.forEach(function (data, idx) {\n            canvasCtx.fillStyle = getFillColor(idx, p);\n            var y = (MAX_VALUE - data) * yRatio;\n            canvasCtx.fillRect(idx * xRatio, y, xRatio + 1, data * yRatio);\n        });\n    };\n    drawAlt();\n}\n","/**\n * Gets the indices of the peaks in a given data array. It searches for\n * a span of values above a threshold, and takes the highest of these\n * values as the \"peak\" for this little \"moutain\" of data.\n *\n * @param {Uint8Array} data the data array of unsigned ints, 8 bits long.\n *   these data can be read as integers in doubt.\n * @param {number} baseline the threshold above which a set of values is\n *   detected and treated as a peak.\n * @returns {number[]} an array of integers representing the indices of the\n *   peaks in the original data array.\n */\nexport function getPeaks(data, baseline) {\n    var results = { peaks: [], max: { index: null, value: null } };\n    var peak = { index: null, value: null };\n    data.forEach(function (item, idx) {\n        if (item > baseline) {\n            if (peak.value == null || item > peak.value) {\n                peak = { index: idx, value: item };\n            }\n        }\n        else if (item < baseline && peak.index != null) {\n            results.peaks.push(peak.index);\n            peak = { index: null, value: null };\n        }\n        if (results.max.value == null || item > results.max.value) {\n            results.max = { index: idx, value: item };\n        }\n    });\n    if (peak.index != null)\n        results.peaks.push(peak.index);\n    return results;\n}\n","export var BASELINE = 80;\nexport var COLOR = \"rgb(100, 100, 100)\";\nexport var FREQ_GAP = 3000 / 4096;\nexport var FFT_SIZE = 4096;\nexport var MAX_COLOR = \"rgb(0, 255, 0)\";\nexport var MAX_DB = 0;\nexport var MAX_VALUE = 255;\nexport var MIN_DB = -100;\nexport var SAMPLE_RATE = 3 * 1e3;\nexport var SMOOTHING_CONSTANT = 0.01;\n","import { COLOR, MAX_COLOR } from \"./constants\";\nimport { updateMax } from \"./updateMax\";\n/**\n * Gets the fill color corresponding to this data point given its\n * index. If it's the max it's in green, if it's another peak it is\n * in red, otherwise it's just grey.\n *\n * @param {number} index the index of the data to get the fill color of.\n * @param {object} pRes the result of the getPeaks function, with the\n *   \"peaks\" and \"max\" keys containing respectively a list of\n *   structures and a structure, each having the keys \"index\" and\n *   \"value\".\n * @returns {str} the string representing the rgb color for this data point.\n */\nexport function getFillColor(index, pRes) {\n    if (pRes.max.index == index) {\n        updateMax(index);\n        return MAX_COLOR;\n    }\n    // else if (pRes.peaks.includes(index)) {\n    //   return PEAK_COLOR;\n    // }\n    else {\n        return COLOR;\n    }\n}\n","import { FREQ_GAP } from \"./constants\";\nimport { NOTES } from \"./notes\";\nimport { closest } from './closest';\nexport function updateMax(index) {\n    var freqWrapper = document.querySelector(\".frequency\");\n    var noteWrapper = document.querySelector(\".note\");\n    var freq = FREQ_GAP * (index + 0.5);\n    freqWrapper.textContent = freq.toFixed(2) + \" Hz\";\n    noteWrapper.textContent = closest(NOTES, freq).n;\n}\n","export function closest(list, item) {\n    return list.reduce(function (prev, curr) {\n        return (Math.abs(curr.f - item) < Math.abs(prev.f - item) ? curr : prev);\n    });\n}\n","export function getMicrophone() {\n    return navigator.mediaDevices.getUserMedia({\n        audio: true,\n        video: false\n    });\n}\n","import { createAnalyser } from \"./audio/createAnalyser\";\nimport { createVisualiser } from \"./audio/createVisualiser\";\nimport { getMicrophone } from \"./audio/getMicrophone\";\nimport { SAMPLE_RATE } from \"./utils/constants\";\ngetMicrophone().then(function (stream) {\n    var context = new AudioContext({ sampleRate: SAMPLE_RATE });\n    var source = context.createMediaStreamSource(stream);\n    var analyser = createAnalyser(context, source);\n    var canvas = document.querySelector('.visualizer');\n    createVisualiser(analyser, canvas);\n});\n","import { FFT_SIZE, MAX_DB, MIN_DB, SMOOTHING_CONSTANT } from \"../utils/constants\";\nexport function createAnalyser(context, source) {\n    var gainNode = context.createGain();\n    var analyser = context.createAnalyser();\n    // Configures the analyser to be correctly displayed afterward.\n    analyser.maxDecibels = MAX_DB;\n    analyser.minDecibels = MIN_DB;\n    analyser.smoothingTimeConstant = SMOOTHING_CONSTANT;\n    analyser.fftSize = FFT_SIZE;\n    // Connects the whole chain source -> gain -> analyser -> output\n    source.connect(gainNode);\n    gainNode.connect(analyser);\n    gainNode.connect(context.destination);\n    return analyser;\n}\n"],"names":["notesNames","notes","currentFirst","_loop_1","i","forEach","note","idx","frequency_jump","push","f","n","NOTES","createVisualiser","analyser","canvas","canvasCtx","getContext","bufferSize","frequencyBinCount","bufferData","Uint8Array","clearRect","width","height","drawAlt","requestAnimationFrame","getByteFrequencyData","fillStyle","fillRect","results","peak","xRatio","yRatio","p","peaks","max","index","value","item","data","list","freqWrapper","document","querySelector","noteWrapper","freq","textContent","toFixed","reduce","prev","curr","Math","abs","updateMax","y","navigator","mediaDevices","getUserMedia","audio","video","then","stream","context","AudioContext","sampleRate","source","createMediaStreamSource","gainNode","createGain","createAnalyser","maxDecibels","minDecibels","smoothingTimeConstant","fftSize","connect","destination"],"sourceRoot":""}